Испытано с Docker 27.3.1, Python 3.11 (хотя должен работать и с более ранними версиями).

# Окружение разработки
Для первого запуска в окружении разработки заполните необходимые переменные в файле `.env.dev`, затем используйте последовательность команд:
```
make build
make up
```

Приложение доступно по адресу http://localhost:8000/
В переменной окружения `LOG_BATCH_SIZE` устанавливается количесво записей для обработки одним пакетом.
Для импорта файла с логами в БД используйте команду

`make import <имя_файла_с_путем>`

# Тестовое окружение

Чтобы использовать тесты, используйте:
```
make build-tests
make tests-up
make tests
```

Для получения отчета о покрытии кода тестами, используйте `make coverage`.

Описание других команд доступно через `make help`.

# Продуктовое окружение

Для запуска в продуктовом окружении используется `docker/prod/docker-compose.yml` и `docker/prod/.env`.
Переименуйте файл `.env.example` в `.env` и заполните переменные окружения.
Переменная `SERVER_NAME` устанавливает доменное имя сервера, которое он делжен обслуживать. По умолчанию localhost.
Переменная `CSRF_TRUSTED_ORIGINS` содержит перечисление доверенных источников для отправляемых форм, разделенных точкой с запятой `;` (без пробелов).
Каждое значение должно содержать не только доменное имя, но и схему протокола (HTTP/HTTPS). Источник проверяется в т.ч. и при попытке входа в административную панель.
По умолчанию, запросы принимаются по HTTP на порту 80.
Чтобы включить HTTPS, нужно положить сертификат в папку `docker/prod/ssl/certs` и ключ к нему в `docker/prod/ssl/private`.
После этого необходимо внести имя файла сертификата *(без пути)* в переменную окружения `SSL_CERTIFICATE`, а имя файла ключа к нему - в `SSL_CERTIFICATE_KEY` и перестроить образ: `make build-prod`.

# Создание собственных парсеров

Парсинг логов основан на 3 сущностях:
1. Парсер одной строки лог-файла типа `Callable[[str], LogRecord]`
2. Класс пакетной записи в БД `app.utils.BatchModelWriter`
3. Класс `nginx_logs.utils.log_importer.LogImporter`, объединяющий их в одну систему.

## Парсер строк

Реализован в виде функции, но может быть любой сущностью, реализующей метод __call__, который принимает на вход одну запись лога и возвращает тип `LogRecord`.

## Тип LogRecord

Это `namedtuple` со следующими полями:
* ip
* date
* method
* uri
* status
* bytes_sent

Служит для временного представления данных из строки лога.

## Класс BatchModelWriter

Это универсальный класс, который можно отдельно использовать по своему усмотрению.
Конструктор принимает класс модели и размер одного пакета для записи в БД.
Метод `add` принимает экземпляр модели и может произвести запись пакета в БД, если накоплено достаточное количество.
Метод `flush` не имеет параметров и выполняет безусловную запись всего накопленного пакета, даже если он заполнен не до конца.
Оба метода возвращают число записанных в БД записей, либо 0, если запись не произведена.

Класс является generic и его экземпляры создаются таким образом:

`writer = BatchModelWriter[MyModel](MyModel, batch_size)`

## Класс LogImporter

Конструктор класса `LogImporter` принимает первым параметром парсер строки, вторым - размер одного пакета для одновременной записи в БД.
Если Вы хотите парсить логи других форматов, Вам нужно создать свой парсер и передать его в конструктор `LogImporter`.
Метод `parse_line` принимает единственную запись из лога, разбирает её и отправляет в очередь на запись.
Возвращает количество записанных в БД строк, либо 0, если запись не произведена, либо -1, если строка не может быть разобрана.
Метод `parse` принимает Iterable строк файла и обрабатывает их по очереди.
Получение обратной связи от `LogImporter` возможно через сигналы:
* `line_parsed` - одна строка лога была успешно разобрана
* `malformed_line` - строка неправильно сформирована и не может быть разобрана
* `flushed` - была произведена запись набора строк в БД